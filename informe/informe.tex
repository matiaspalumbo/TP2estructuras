\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs} % Cursive font
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{fancyhdr}
\usepackage{nameref}
\usepackage{wrapfig}


\usepackage{mathtools, stmaryrd}
\usepackage{xparse} \DeclarePairedDelimiterX{\Iintv}[1]{\llbracket}{\rrbracket}{\iintvargs{#1}}
\NewDocumentCommand{\iintvargs}{>{\SplitArgument{1}{,}}m}
{\iintvargsaux#1}
\NewDocumentCommand{\iintvargsaux}{mm} {#1\mkern1.5mu,\mkern1.5mu#2}

\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother

\usepackage[a4paper,hmargin=1in, vmargin=1.4in,footskip=0.25in]{geometry}

\graphicspath{ {./images/} }


%\addtolength{\hoffset}{-1cm}
%\addtolength{\hoffset}{-2.5cm}
%\addtolength{\voffset}{-2.5cm}
\addtolength{\textwidth}{0.2cm}
%\addtolength{\textheight}{2cm}
\setlength{\parskip}{8pt}
\setlength{\parindent}{0.5cm}
\linespread{1.5}

\pagestyle{fancy}
\fancyhf{}
\rhead{TP2 - Cipullo, Palumbo}
\lhead{Estructuras de Datos y Algoritmos I}
\rfoot{\vspace{1cm} \thepage}

\renewcommand*\contentsname{\LARGE Índice}

\begin{document}

\begin{titlepage}
    \hspace{-1.2cm}\includegraphics[scale= 0.8]{header2}
    \begin{center}
        \vfill
        \vfill
            \vspace{0.7cm}
            \noindent\textbf{\Huge Trabajo Práctico 2}\par
            \vspace{.5cm}
        \vfill
        \noindent \textbf{\huge Integrantes:}\par
        \vspace{.5cm}
        \noindent \textbf{\Large Cipullo, Inés}\par
        \noindent \textbf{\Large Palumbo, Matías}\par
 
        \vfill
        \large Universidad Nacional de Rosario \par
        \noindent\large 2020
    \end{center}
 \end{titlepage}
 \ \par


\noindent A continuación, se detallan las elecciones en general y particularidades que nos resultaron relevantes en la resolución del Trabajo Práctico 2.\par


\section{Elección de estructura de datos}

La estructura de datos utilizada a lo largo del programa es Árboles de Intervalos donde los nodos siguen un orden lexicográfico, e implementados como árboles binarios balanceados.
La estructura de árbol de intervalos incluye, además de los elementos usuales de la estructura de árbol binario (los punteros \verb|left| y \verb|right|, al subárbol izquierdo y derecho respectivamente), 
tres variables del tipo de dato \verb|double|, \verb|izq| y \verb|der| que representan los extremos del intervalo y por lo tanto son el dato de la estructura, y \verb|max| que representa el máximo extremo derecho entre los intervalos contenidos en ese subárbol.
También incluimos una variable del tipo \verb|int| que es la altura del nodo. \par

Si bien hace a la generalidad de la estructura del árbol y de la implementación de la estructura el uso de una estructura auxiliar para almacenar el dato, en este caso un intervalo, no lo creimos necesario ya que no nos pareció que agregase una generalidad significante y entorpecia la legibilidad del código.
Asimismo, la decisión de agregar la variable \verb|altura| a la estructura se basó principalmente en buscar evitar recorrer el árbol completo cada vez que se necesite la altura o el factor de balance de un nodo.\par


\section{Compilación de los archivos}

La estructuración de los archivos y sus dependencias se encuentra detallada en el archivo \textit{makefile}. 
Para compilar el programa se utiliza el comando \verb|make interprete| o \verb|make|. A su vez, luego de la compilación, el ejecutable del intérprete se corre mediante el siguientes comando:\par

\noindent \verb|./interprete|. \par


\section{Decisiones en el comportamiento}

\subsection{Comandos del intérprete}

El intérprete para manipular árboles de intervalos desde la entrada estándar soporta los siguientes comandos:

\vspace{-0.5cm}
\begin{itemize}
    \item \verb|i [a, b]|
    \vspace{-0.3cm}
    \item \verb|e [a, b]|
    \vspace{-0.3cm}
    \item \verb|? [a, b]|
    \vspace{-0.3cm}
    \item \verb|dfs|
    \vspace{-0.3cm}
    \item \verb|bfs|
    \vspace{-0.3cm}
    \item \verb|salir|
\end{itemize}
\vspace{-0.5cm}

\noindent donde \verb|[a, b]| es un intervalo bien definido ($a \le b$).
Además, vale aclarar que es case-sensitive, es decir, distingue minúsculas de mayúsculas, y que en los tres primeros casos, los comandos llevan un espacio entre el primer caracter y el corchete que inicia el intervalo, y entre la coma y el segundo número. \par

En cuanto a los mensajes de error, hace una distinción que nos pareció significativa. Imprime el mensaje \verb|Intervalo no valido| en caso de que la estructura del comando ingresado sea correcta pero el intervalo ingresado no este correctamente definido (es decir, $a > b$), 
e imprime el mensaje \verb|Comando no valido| si se ingresa cualquier comando que rompa con las especificaciones antes dadas. \par

\subsection{Recorrido DFS}

La función que realiza el recorrido primero en profundida del árbol de intervalos fue hecha de forma recursiva, y no iterativa. 
Esto fue porque la estructura de árbol con la que trabajamos es recursiva y al trabajar con árboles balanceados la altura de los mismos se ve limitada al logaritmo de la cantidad de nodos del árbol, y por lo tanto la recursión en este contexto no representaba dificultades mayores en cuanto al uso de memoria. \par
Por otro lado, realiza el recorrido DFS siguiendo el orden in-order, pues siendo que el árbol sigue un orden lexicográfico, este orden permite recorrerlo, y consecuentemente imprimirlo, de forma ordenada de manor a mayor. \par

\subsection{Impresión de los intervalos}

El formato elegido para la impresión de los intervalos en la salida estádar es \verb|%g| porque ... 


\section{Dificultades encontradas}

Cómo leer por la entrada estándar; porque usamos fgets.


\section{Bibliografía}
\begin{itemize}
    \item \verb|https://www.geeksforgeeks.org/avl-tree-set-1-insertion/|
    \item \verb|https://www.geeksforgeeks.org/avl-tree-set-2-deletion/|
    \item \verb|https://en.wikipedia.org/wiki/Interval_tree|
\end{itemize}


\end{document}
